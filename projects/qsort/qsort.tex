

%\newcommand*{\ACM}{}%

\ifdefined\ACM

%\documentclass[sigplan,screen]{acmart}
  \documentclass[manuscript,screen,review]{acmart}

\else
  \documentclass{article}
  \input{./usepackage}
  \addbibresource{./sample.bib} 

\fi

\begin{document}

\input{newcommands}

\title{$\log n$ - Space, $n^{3/2}$ Time Quantum Sort.} 
\author{David Ponarovsky}
%\author{Noa Viner, David Ponarovsky}
\maketitle
%It were proven that any quantum algoirthm in the quantum circuits which sorts at time $T$ and storage space $S$ has to satisfty the restrication $TS = \Omega(n^{3/2})$ \cite{klauck2003quantum} where in the regime of $S \ge \log^{3}(n) $ they shown that the bound is tight up to logratmic factors. Yet in the regime where $S$ is strictly $\Theta(\log(n))$ no much advences as been reached byeoned the $T = n^{1 \frac{1}{2}} \log n$. Here we preasent a quantum algorithm that sort at $\log(n)$ storage memory and $n^{3/2}$ time. We achieved that by quntifiy the sort algorithm invented by Stanley P. Y. Fung \cite{Simplesort} who coined its name - "ICan'tBelieveItCanSort" - due to the surprise of having such a simple sorting algorithm. 

It has been proven that any quantum algorithm in the quantum circuits which sorts at time $T$ and storage space $S$ has to satisfy the restriction $TS = \Omega(n^{3/2})$ \cite{klauck2003quantum}. In the regime of $S \ge \log^{3}(n)$, it has been shown that the bound is tight up to logarithmic factors. However, in the regime where $S$ is strictly $\Theta(\log(n))$, not much advancement has been reached beyond $T = n^{1 \frac{1}{2}} \log n$. Here, we present a quantum algorithm that sorts with $\log(n)$ storage memory and $n^{3/2}$ time. We achieved this by quantifying the sorting algorithm invented by Stanley P. Y. Fung \cite{Simplesort}, who coined its name - "ICan'tBelieveItCanSort" - due to the surprise of having such a simple sorting algorithm.

\begin{algorithm}
\SetAlgoLined
\KwResult{Sorting $A_{1},A_{2},..A_{n}$ }
\caption{ "ICan'tBelieveItCanSort"  alg.}
\For{ $ i \in [n]$} {
  \For{ $ j \in [n]$} {
    \If { $A_{i} < A_{j} $} {
      swap $A_{i} \leftrightarrow A_{j}$
    }
  }
}
\end{algorithm}
\begin{algorithm}

\SetAlgoLined
\KwResult{Sorting $A_{1},A_{2},..A_{n}$ }
\caption{ "ICan'tBelieveItCanSort"  alg.}
swap $A_{1} \leftrightarrow \max A$ \\
\For{ $ i \in [n-1]$} {
    Find the first $k$ such $A_{k} > A_{i}$ \\
    Set $A \leftarrow A_{1},A_{2}..A_{k-1},A_{i},A_{k},A_{k+1},..,A_{i-1},A_{i+1}..,A_{n}$
}
\end{algorithm}

\begin{algorithm}
\SetAlgoLined
\KwResult{Sorting $A_{1},A_{2},..A_{n}$ }
\caption{ "Quantum ICan'tBelieveItCanSort"  alg.}
swap $A_{1} \leftrightarrow \max A$ \\
\For{ $ i \in [n-1]$} {
    Set current $\leftarrow$ head.next \\

    $k$-pointer $\leftarrow$ Find the first '$k< i$' node such '$A_{k} > A_{i}$' using Grover querying the follow \\
    \ \ Ask if ( node.color $=$ red and node.value $ > $ current.value \\ 
    \ \ \ \ and node.back.value $\le$ current.value ) \\ 

    Set head.next $\leftarrow$ head.next.next \\
    Set head.next.back $\leftarrow$ head\\
    Set current.next $\leftarrow$ $k$-pointer \\
    Set current.back $\leftarrow$ $k$-pointer.back \\
    Set current.back.next $\leftarrow$ current \\ 
    Set current.color $\leftarrow$ red
}
\end{algorithm}
\printbibliography
\end{document}





