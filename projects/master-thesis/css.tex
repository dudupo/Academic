\ifdefined\CSSDOC
\begin{document}
\fi 

\ctt{Add a definition of error weight. fault that spanned by pauli operator of degree at} 

\begin{definition}[CSS Code]
  Let $C_{X}, C_{Z}$ classical linear codes such that $C_{Z}^{\perp} \subset C_{X}$ define the $Q\left( C_{X},C_{Z} \right)$ to be all the code words with following structure:
  \begin{equation*}
    \begin{split}
    \ket { \mathbf{ x } } := \ket { x + C_{Z}^{\perp} } = \frac{1}{\sqrt{C_{Z}^{\perp}}} \sum_{z \in C_{Z}^{\perp}}{ \ket{ x + z }} 
    \end{split}
  \end{equation*}
\end{definition}
Clearly, the codewords are all the codewords in $C_{X}$ which don't belong to $C_{Z}^{\perp}$ and therefore the dimension of the quantum code is $\dim Q\left( C_{X}, C_{Z} \right) = \dim C_{X} - \dim C_{Z^{\perp}} = \dim C_{X} + \dim C_{Z} - n$. Yet, it's not stems immediately how one can correct faults. Next, we are going to repeat the decoding process of the Shor code in the general setting of CSS codes.  
\begin{lemma}
  Let $C_{X},C_{Z}$ classical codes such $Q\left( C_{X},C_{Z} \right)$ is a CSS code. Let $d_{X}$ be the minimal weigh of codeword in $C_{X}$ which is not in $C_{Z}^{\perp}$, and define by the same way $d_{Z}$ to be the minimal weight of codeword in $C_{Z}$ which doesn't belong to $C_{X}^{\perp}$. Then the distance of $Q\left( C_{X},C_{Z} \right)$ equals to $\min{d_{X},d_{Z}}$. Moreover there is a decoder which correct any fault with weight at most $d/2$.       
  \end{lemma}

    \newcommand{\GZZZ}[1]{ \frac{1}{\sqrt{|C_{Z}^{\perp}|}} \sum_{z \in C_{Z}^{\perp}}{ #1 } } 
    \newcommand{\GZZZW}[2]{ \frac{1}{\sqrt{|C_{Z}^{\perp}|}} #2 \sum_{z \in C_{Z}^{\perp}}{ #1 } } 
    \newcommand{\GXXX}[1]{ \frac{1}{\sqrt{|C_{Z}|}} \sum_{z \in C_{Z}}{ #1 } } 
    \newcommand{\GXXXW}[2]{ \frac{1}{\sqrt{|C_{Z}|}} #2 \sum_{z \in C_{Z}}{ #1 } } 
    \newcommand{\GXXXV}[2]{ \frac{1}{\sqrt{|C_{Z}|}} \sum_{#2 \in C_{Z}}{ #1 } } 
  \begin{proof}
    First let us prove the following claim: 
    \begin{claim}
      Denote by $H^{\otimes n}$ the Hadamard gate over $n$ qubits. Then for any code $C$ it holds that: $  H^{n}\ket{C^{\perp}} = \ket{C} $
          \end{claim}
    \begin{proof}
      \begin{equation*}
        \begin{split}
        H^{n}\ket{C^{\perp}} &= \GZZZ{ H^{n}\ket{z} } = \frac{1}{ \sqrt{ 2^{n}}} \GZZZ{ \sum_{y\in \mathbb{F}_{2}^{n}}{ (-1)^{\braket{z,y}}  \ket{y}}  }\\
        = & \frac{1}{ \sqrt{ 2^{n}}} \GZZZ{ \left( \GXXXV{ \ket{y} }{y} + \text{ other terms } \right) } 
        \end{split}
       \end{equation*}
Since the columns of matrix $H_{Z}$ form a basis for the complementary space $C_{Z}^{\perp}$, and due to the dimensional theorem and the equivalence between the row rank and column rank of a matrix, we can deduce that $\dim \rank H_{Z}^{\top} + \dim \ker H_{Z} = n$, which implies that $|C_{Z}^{\perp}||C_{Z}| = 2^{n}$

Notice that $ 2^{n}|C_{Z}^{\perp}| =  |C_{z}| \cdot |C_{Z}^{\perp}| \cdot |C_{Z}^{\perp}|$ 
    \end{proof}
    \begin{claim}
      For any $x_{0} \in C_{X}$ and $z_{1}\neq z_{2} \in C_{z}^{\perp}$, $D_{X}$ correct $\ket{x+z_{1}+f}$, $\ket{x+z_{2}+f}$ into two different words in $C_{X}$. 
    \begin{proof}
      Suppose not, namely there exists $y \in C_{X}$ such that $D_{X}$ correct $\ket{x+z_{1}+f}$, $\ket{x+z_{2}+f}$ into $\ket{y}$. Then we have that for both $i\in \{1,2\}$ it holds that  $d\left( x+z_{i} +f, y \right) \le d\left( C_{Z}^{\perp}/2 \right)$ and therefore $ d\left( x + z_{1} + f, x+z_{2} +f  \right) \le d\left( C_{Z}^{\perp} \right)$. But
      \begin{equation*}
        \begin{split}
            & d\left( x + z_{1} + f, x+z_{2} +f  \right) =  | x + z_{1} + f + x + z_{2} + f | \\
            =  & | z_{1} + z_{2} | = d\left( z_{1},z_{2} \right) 
        \end{split}
      \end{equation*}     
      contradiction for the assumption that $z_{1},z_{2} \in C_{Z}^{\perp}$.   
    \end{proof}
    \end{claim} 
    Let $P = X^{f}Z^{e}$ be an error such that $e, f < d/2$ act on the state $\ket{\mathbf{x}}$. Denote by $H_{X}, H_{Z}$ the parity check matrices of $C_{X},C_{Z}$. 
      \begin{equation*}
      \begin{split}
        \ket{\mathbf{x}} &  \mapsto^{P}   \frac{1}{\sqrt{|C_{Z}^{\perp}|}} \sum_{z \in C_{Z}^{\perp}}{ X^{f}Z^{e}\ket{ x + z }} = \frac{1}{\sqrt{|C_{Z}^{\perp}|}} \sum_{z \in C_{Z}^{\perp}}{ (-1)^{\braket{e,f} }Z^{e}\ket{ x + z + f}}\\
        & \mapsto^{H_{X}} \GZZZ{ (-1)^{\braket{e,f} }Z^{e}\ket{ x + z + f} \ket{ H_{X} \left(x + z + f\right) }  } \\ 
        & = \ \ \ \ \ \GZZZ{ (-1)^{\braket{e,f} }Z^{e}\ket{ x + z + f} \ket{ H_{X}f }  }\\
        & \mapsto^{X^{f}} \GZZZ{ Z^{e}\ket{ x + z} \ket{ H_{X}f }  }  \mapsto^{H^{\otimes n}} \GZZZ{  X^{e}H^{\otimes n}\ket{ x + z} } \\
        & = \GZZZ{  X^{e}H^{\otimes n} X^{x} \ket{ z} }  = \GZZZ{  X^{e} Z^{x} H^{\otimes n} \ket{ z} } \\
        & = \GZZZW{ \ket{ z} }{X^{e} Z^{x} H^{\otimes n} }  =  \GXXXW{  \ket{ z} }{ X^{e} Z^{x} } \\
        & =  \GXXXW{   X^{e}\ket{ z} }{ (-1)^{\braket{x,e}} Z^{x}}  =  \GXXXW{   \ket{ z + e} }{ (-1)^{\braket{x,e}} Z^{x}} \\
        & =  \GXXXW{   \ket{ z + e} \ket{ H_{Z}e }}{ (-1)^{\braket{x,e}} Z^{x}} \\
        & \mapsto  \GXXXW{   \ket{ z } \ket{ H_{Z}e }}{ (-1)^{\braket{x,e}} Z^{x}} \mapsto^{H^{n}}  \GZZZW{   \ket{ z }}{ X^{x}}\\ 
        & = \GZZZ{ \ket{z + x}} = \ket{\mathbf{x}}
      \end{split}
    \end{equation*}
  \end{proof}
  
  There is still one big difference between the classic repetition code and the Shor code. While each parity check of the Shor code examines a square root number of qubits, any check of the repetition code touches no more than a constant number of qubits; that is, any check just tests if any two adjacent bits are equal.  That brings us to ask whether the Shors code is really the quantum analogy for the repetition code? 

  For getting an hint before formally presenting a quantum LDPC code, let's take another look on the general structure of the CSS codes. The decoding procedure the proof above teach us an additional point about CSS code, the task of finding a good code quantum code, could be reduce for finding a two classic binary linear codes which their parity check matrices ortogonal to each other. Furthermore, if one is willing to has an qLDPC code, then $H_{X}$ and $H_{Z}$ can't be parity check matrices of good classical code as any column of $H_{z}^{\top}$ is a codeword of $C_{X}$. 
  \begin{equation*}
    \begin{split}
      C_{Z}^{\perp} \subset C_{X} \Rightarrow H_{X}H_{Z}^{\top} = 0 
    \end{split}
  \end{equation*}


\ifdefined\CSSDOC
\end{document}
\fi 
